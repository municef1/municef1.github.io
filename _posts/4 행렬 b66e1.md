# 4. 행렬

# 행렬

## 행렬 Matrix

사각 괄호로 둘러 쌓인 숫자들의 배열 (Rectangular array of numbers written between square brackets)

![스크린샷 2022-04-12 오후 5.07.04.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.07.04.png)

볼드 대문자 표시 **A, B**

행렬의 차원(크기) : 행 개수 * 열 개수

![스크린샷 2022-04-12 오후 5.08.10.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.08.10.png)

보기의 경우 m * n 행렬

요소의 첫 번째 인덱스가 행번호, 두 번째 인덱스가 열 번호

## 행렬의 덧셈과 스칼라 곱셈

![스크린샷 2022-04-12 오후 5.09.01.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.09.01.png)

## 행렬 - 행렬의 곱셈

일반적인 설명 : 행과 열의 요소를 곱해서 더함

![스크린샷 2022-04-12 오후 5.09.37.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.09.37.png)

## 행렬의 전치 Transpose

주어진 행렬의 행을 열로, 열을 행으로 이동

![스크린샷 2022-04-12 오후 5.11.20.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.11.20.png)

해석 : 1부터 7까지를 2 * 3 행렬로 만들기 → 가로 세로를 서로 바꿔주기! (transpose)

.transpose

.T

## 특별한 행렬

단위 행렬 unit, identity matrix

- 대각 성분이 모두 1인 n*n 정사각 행렬
- 1이랑 똑같게 생각.
- AI = IA = A

![스크린샷 2022-04-12 오후 5.17.40.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.17.40.png)

대각행렬 diagonal matrix

- 대각 성분만 0이 아닌 성분을 가진 n*n 정사각 행렬

![스크린샷 2022-04-12 오후 5.19.09.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.19.09.png)

이런 녀석들!

대칭행렬 symmetric matrix

![스크린샷 2022-04-12 오후 5.20.11.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.20.11.png)

직교행렬 orthogonal matrix

![스크린샷 2022-04-12 오후 5.20.33.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.20.33.png)

## 행렬을 이용한 데이터 표현 : 테이블형 데이터

신체특징 데이터 : 키, 몸무게, 혈압 ~~~

한 명 데이터를 벡터로 표시 : x = (키, 몸무게, 혈압, ~~~)T

개별 데이터를 행 벡터로 저장

데이터 행렬 **X** : (N,D), N : 데이터 개수, D : 데이터 차원

N, D 라는거 그냥 외우기!

![스크린샷 2022-04-12 오후 5.22.38.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.22.38.png)

## *중요 * 행렬을 이용한 데이터 표현 : 이미지

Channel first : (C, H, W), Channel last: (H, W, C)

![스크린샷 2022-04-12 오후 5.24.43.png](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.24.43.png)

# 행렬과 벡터 파이썬

```python
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
```

## 덧셈

```python
# 행렬과 행렬의 덧셈은 요소끼리 덧셈
A = np.matrix([[1,2],[3,4]])
B = np.matrix([[10,20],[30,40]])

A+B
```

```python
A = np.array([[1,2],[3,4]])
B = np.array([[10,20],[30,40]])

A+B
```

## 스칼라 곱셈

```python
# 행렬과 스칼라의 곱셈은 전체 요소에 곱셈
3*B
```

## 곱셈

```python
# 행렬과 행렬의 곱셈
A = np.array([[1,2,3], [4,5,6]]) 
B = np.array([[2,1], [1,2], [1,1]])
print(np.dot(A,B))

# 그냥 곱하면 에러가 남 
# A*B 안됨! A@B는 아마 될거임

########################################
# 그냥 곱하고 싶으면?
A_ = np.matrix(A)
B_ = np.matrix(B)
A_*B_
```

## 행렬의 전치

```python
# 열을 행으로 행을 열로
A = np.matrix([[1,2,3],[4,5,6]])
print(A)
print(A.T)
```

```python
# 곱의 전치
B = np.matrix([[3,4],[6,5],[1,2]])

print((A*B).T)
print(B.T * A.T)
```

## 단위행렬

```python
A = np.matrix([[2, 4], [4, 2]])
I = np.matrix(np.eye(2))

print(A*I)
print(I*A)
```

## 행렬을 이용한 데이터 표현

### 테이블형 데이터

```python
from sklearn.datasets import load_iris
```

```python
data = load_iris()
 
pd.DataFrame(data.data, columns=data.feature_names)
```

### 이미지

```python
!gdown --id 1ycxVgUkjUy4UX8KhXTfJ1QoENIz_zRYv
```

```python
import matplotlib as mpl
```

```python
old_python = mpl.image.imread('old_python.png')
```

```python
old_python.shape
```

```python
fig, ax = plt.subplots(figsize=(15,5), nrows=1, ncols=5)

ch = ['Red', 'Green', 'Blue', 'Alpha']
cm = ['Reds', 'Greens', 'Blues', 'binary']

for i, ax_i in enumerate(ax[:-1]):
    ax_i.imshow(old_python[:,:,i], cmap=cm[i])
    ax_i.set_title(ch[i])

ax[-1].imshow(old_python)

plt.show()
```

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled.png)

## 행렬곱 (2022.04.14)

## 행렬 곱셈을 이해하는 필살기

- 행렬 곱은
    - 뒤에서 곱하는 행렬의 각 열의 요소를 계수로 앞 행렬의 모든 열을 선형 결합 (linear combination)
    - 앞에서 곱하는 행렬의 각 행의 요소를 계수로 뒤 행렬의 모든 행을 선형결합
    - 앞에서 곱하는 행렬의 열과 뒤에서 곱하는 행렬의 행을 외적한 것들의 합

## 행렬 곱셈 : 열 결합

- 뒤에서 곱하는 벡터의 요소를 계수로 한 모든 열의 선형결합(linear combination)

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled%201.png)

- 열 결합

```python
A = np.random.randint(1,10,12).reshape(4,3)
b = np.random.randint(1,10,3)

np.dot(A,b)
```

```python
# 행렬*벡터 열 결합 [+]
c = np.zeros(4, dtype=int)
for i in range(A.shape[1]):
    c += A[:,i]*b[i]

c
```

```python
A = np.random.randint(1,10,12).reshape(4,3)
B = np.random.randint(1,10,6).reshape(3,2)
np.dot(A,B)
```

```python
C = np.zeros((4,2))

# 행렬*행렬 열결합 [+]
for j in range(B.shape[1]):
    c = np.zeros(4, dtype=int)
    for i in range(A.shape[1]):
        c += A[:,i]*B[i,j]

    C[:,j] = c

print(C)
```

## 행렬곱셈 : 행 결합

- 앞에서 곱하는 행렬의 행 요소를 계수로
- 뒷 행렬의 행을 조합하여 결과의 행을 계산
- 열 결합 방식을 전치시키면 성립

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled%202.png)

### 행 결합

```python
At = A.T
Bt = B.T

np.dot(Bt,At)
```

```python
C = np.zeros((2,4))

# 행렬*행렬 행결합 [+]
for i in range(Bt.shape[0]):
    c = np.zeros(4, dtype=int)
    for j in range(At.shape[0]):
        c += Bt[i,j] * At[j,:]

    C[i,:] = c

print(C)
```

## 행렬 곱셈 : 외적 합

- 앞, 뒤 행렬을 모두 벡터 요소로 표현하면

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled%203.png)

### 외적합

```python
A = np.random.randint(1,10,12).reshape(4,3)
B = np.random.randint(1,10,6).reshape(3,2)

np.dot(A,B)
```

```python
C = np.zeros((4,2))

# 행렬*행렬 외적합[+]
for j in range(A.shape[1]):
    C += np.dot(A[:,[j]], B[[j],:])

print(C)
```

## 인공신경망의 행렬 표현

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled%204.png)

### 데이터 로딩

```python
data = pd.read_csv('data.csv', names=['x', 'y', 'target'])
data['bias'] = 1
data
```

```python
fig = plt.figure(figsize=(5,5))
ax = plt.axes()

ax.plot(data[data['target']==1]['x'], data[data['target']==1]['y'], 'o')
ax.plot(data[data['target']==0]['x'], data[data['target']==0]['y'], 'x')

plt.show()
```

![Untitled](4%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20b66e1/Untitled%205.png)

```python
X = data[['bias', 'x', 'y']].to_numpy()
y = data['target']
```

### 점 하나씩 계산

```python
def sigmoid(x):
    return 1 / (1+np.exp(-x))

W1 = np.array([
    [-15, 3, 5],
    [18, -6, -3]              
])

W2 = np.array([
    [4, 10, -9]
])

# 0번 점에 대해서만 계산, 엑셀 시트와 똑같은 상황[+]
a = sigmoid( np.dot(W1, X[0].T) )
print(a)
a = np.concatenate(([1], a))
print(a)
y_hat = sigmoid( np.dot(W2, a) )

y_hat, y[0]
```

### 모든 점을 한번에 계산

```python
# 행렬곱으로 모든점을 한번에 계산[+]
a = sigmoid( np.dot(W1, X.T) )
print(a.shape)
a = np.concatenate((np.ones(500).reshape(1,-1), a))
print(a.shape)
y_hat = sigmoid( np.dot(W2, a) )
```

```python
pd.DataFrame([y_hat[0], y]).T
```

```python
y_hat = y_hat[0] >=0.5
y_hat
```

```python
(y_hat != y).sum()
```

# 퀴즈!

11. 다음은 행렬의 크기를 (행,열)로 나타낸 것이다. 서로 곱셈이 가능한 행렬끼리 짝지어 진것은?

(1,2), (1,2)

(2,3), (3,4)

(4,5), (3,4)

(2,1), (2,1)

12. 두 행렬 A, B에 대한 행렬곱 AB를 해석할 수 있는 방법이 아닌것은?
A행렬의 열을 B행렬의 열의 요소로 선형조합
B행렬의 행을 A행렬의 행의 요소로 선형조합
A행렬의 열과 B행렬의 행을 외적하여 모두 합산
B행렬의 열을 A행렬의 행의 요소로 선형 조합