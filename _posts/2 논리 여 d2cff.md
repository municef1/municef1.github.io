# 2. 논리 연산

# 논리 연산

## 명제 proposition

진릿값 truth value : 참, 거짓을 나타내는 값

- True : T, 1
- False : F, 0

명제 proposition : 진릿값(참, 거짓)을 부여할 수 있는 문장이나 식

- 주로 p, q, r
- 5+4 = 9 : 참 명제
- 제주는 한국의 수도다 : 거짓 명제
- 머신러닝은 어렵다 : 참거짓 안되므로 명제 아님

## 논리 연산자 : 부정

논리 연산자 : 명제에 적용되는 연산자

부정 연산자 ㄱ

- 명제 p에 대해 ‘p가 아니다'를 의미하는 연산자
- 진릿값은 반대
    
    ![스크린샷 2022-04-12 오전 10.37.21.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.37.21.png)
    

## 논리 연산자 : 논리곱 AND

p ∧ q : 명제p와 q에 대해 ‘p그리고 q’를 의미

p와 q 모두 참일때만 결과가 참

![스크린샷 2022-04-12 오전 10.39.22.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.39.22.png)

## 논리연산자 : 논리합 OR

p ∨ q : 명제 p와 q에 대해 ‘p 또는 q’를 의미

p와 q 둘 중 하나만 참이면 결과가 참

![스크린샷 2022-04-12 오전 10.40.30.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.40.30.png)

## 논리 연산자 : 배타적 논리합 XOR

p ⊕ q : 명제 p와 q에 대해 둘 중 하나만 참일 때 참이고 나머지는 거짓이 되는 연산

![스크린샷 2022-04-12 오전 10.43.29.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.43.29.png)

## 조건과 진리집합

조건 : x에 따라 참, 거짓을 판별할 수 있는 명제

- x < 10 : 참, 거짓 판단 불가능
- 전체 집합 U가 N이면 x = {1,2,3,4,5,6,7,8,9}인 경우 참
- 나머지는 거짓

진리집합

- 조건을 참으로 만드는 원소의 집합
- x = {1,2,3,4,5,6,7,8,9}
- 명제가 거짓이라면 진리집합이 공집합이라는 의미

## 조건 명제 conditional proposition

![스크린샷 2022-04-12 오전 10.49.21.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.49.21.png)

p 면 q 다!

이게 참이든 거짓이든 뭐면(입력, 전제, 가정), 뭐다(출력, 결론, 결과)!가 돼야함

P 진리집합

Q 진리집합

P ⊂ Q 이면 p -> q는 참

P ⊂/ Q 이면 p -> q는 거짓

## 조건 명제의 진리표

p > q의 진리 판단은 P⊂Q, P가 Q의 부분집합인가에 따라 판단

![스크린샷 2022-04-12 오전 11.03.23.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.03.23.png)

![스크린샷 2022-04-12 오전 11.11.22.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.11.22.png)

![스크린샷 2022-04-12 오전 11.11.46.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.11.46.png)

![스크린샷 2022-04-12 오전 11.12.01.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.12.01.png)

아까 공집합의 위치에 대해 헷갈릴 수 있어 예시를 듭니다. 

엘리베이터 1 엘리베이터 2에 김이박이 타는 경우(서로 포함되지 않는 두 집합), 

엘리베이터 1에 (김) (이) (박) (김이) (김박) (이박) (김이박) (안탐)이라는 상태가 존재할 수 있습니다. 

엘리베이터2에도 똑같은 상태가 존재할 수 있습니다. 

하지만 엘리베이터 1에 박이 포함되었는데 엘리베이터 2에는 박이 존재할 수 없습니다. 선택할 수 있는 경우의 수는 (김) (이) (김이) (안탐) 입니다.

엘리베이터 1과 2에 동시에 박이 들어갈 수 없는 특성을 의미합니다.

하지만 엘리베이터 1과 2가 모두 동시에 (안탐)이 될 수가 있습니다.

공집합은 1과 2라는 집합, 모든 집합에 베이스로 깔려있는 “공기"처럼 생각을 해도 될 것 같습니다!

## 조건 명제 : 일상 언어

“90점 이상 맞으면 아이폰 사 줄게”

p : 90점 이상 맞음

q : 아이폰 사줌

아빠가 나에게 저 명제를 이야기했다면

- 90점 이상 맞음 > 아이폰 사줌 >>> 아빠 거짓말 안했음
- 90점 이상 맞음 > 아이폰 안 사줌 >>> 아빠 거짓말함!!!!!!
- 90점 이상 못 맞음 > 아이폰 사줌 >>> 아빠 거짓말 안했음(못맞아도 안사준다곤 안함)
- 90점 이상 못 맞음 > 아이폰 안사줌 >>> 아빠 거짓말 안했음

## 필요조건과 충분조건

![스크린샷 2022-04-12 오전 11.24.04.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.24.04.png)

![스크린샷 2022-04-12 오전 11.31.54.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.31.54.png)

**q가 p보다 넓은 영역(크면) : p는 q이기 위한 충분조건!, q는 p이기 위한 필요조건!**

**p가 q보다 넓은 영역(크면)  : p는 q이기 위한 필요조건!, q는 p이기 위환 충분조건!**

필요조건과 충분조건의 활용

![스크린샷 2022-04-12 오전 11.39.10.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.39.10.png)

![스크린샷 2022-04-12 오후 5.19.09.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.19.09.png)

왜 필요조건 충분조건에서 이 예시가 나왔는가!

f’(x) = 0이 조건이 돼야 적어도 최소조건이 될 수 있다.

# 오후시간 강의

[Google Colaboratory](https://colab.research.google.com/drive/1T22sydKtUDlMEaCZr21pLQ5kJG0xqtk_#scrollTo=TXYsyzBZJxlB)

```python
import numpy as np
import matplotlib.pyplot as plt
import sympy as S
from sympy.utilities.autowrap import ufuncify
```

```python
# 함수 f(x)를 심볼릭으로 정의 [+]
x_ = S.Symbol('x')

fx = S.expand(-(x_ - 2)**2 * (x_ - 4)**3)
fx
```

```python
# fx로 부터 파이썬 함수형태로 변경
# https://pnavaro.github.io/python-notebooks/15-Sympy.html
f = ufuncify([x_], fx, backend='f2py') 

# def f(x):
#     return -(x**5 - 16*x**4 + 100*x**3 - 304*x**2 + 448*x - 256)
```

```python
# fx를 미분
dfx = S.diff(fx, x_)

dfx
```

```python
# 도함수도 파이썬 함수형태로 변경
df = ufuncify([x_], dfx, backend='f2py') 
# def df(x):
#     return -5*x**4 + 64*x**3 - 300*x**2 + 608*x - 448
```

```python
# 한번 미분한 dfx를 =0 으로 두고 방정식 풀이 [+]
sols = np.array(S.solvers.solve(dfx, x_))
sols
```

```python
# 풀이된 x위치에서 함수값 계산 [+]
# 두개가 0으로 나오는데 이 둘다 로컬 미니멈인지 알 수 없음
f(sols)
```

```python
# 로컬 미니멈을 확인하기 위해 한번 더 미분
ddfx = S.diff(dfx, x_)
ddfx
```

```python
ddf = ufuncify([x_], ddfx, backend='f2py') 
# def ddf(x):
#     return -20*x**3 + 192*x**2 - 600*x + 608
```

```python
# 두 번 미분한 함수에서 함수각을 계산 ddf > 0 인 위치가 로컬 미니멈 [+]
ddf(sols)
```

```python
x = np.linspace(1.5, 4.5, 100)

fig = plt.figure(dpi=150)
ax = plt.axes()

ax.plot(x, f(x), label='f', color='k')
ax.plot(x, df(x), label="f'", color='0.7', ls='--')
ax.plot(x, ddf(x), label="f''", color='0.7', ls='-.')
ax.plot(sols, f(sols), 'o', markersize=8, c='r')
ax.plot(sols, [0, 0, 0], 'x', color='k', label="f'(x)=0")
ax.hlines(y=0, xmin=1.5, xmax=4.5)

ax.text(1.8, -0.3, 'minimum')
ax.text(2.5, 1.3, 'maximum')
ax.text(3.8, -0.3, 'saddle')

ax.legend()
ax.set_ylim([-2,3.5])
plt.show()
```

![Untitled](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/Untitled.png)

f’(x) = 0 이면서 f’’(x) > 0 이면 local minimum

f’(x) = 0 이면서 f’’(x) < 0 이면 local maximum

f’(x) = 0 이면서 f’’(x) = 0 이면 saddle point

- 다변수 함수의 극대, 극소에 대한 추가 정보는 여기서!

[[미분적분학] 다변수함수의 극대, 극소, 안장점](https://subprofessor.tistory.com/66)

## Boolean Algebra

부울 대수 Boolean algebra : 집합 {0,1}과 NoT, AND, OR 연산으로 구성되는 식과 그에 대한 연산

![스크린샷 2022-04-12 오후 1.22.54.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.22.54.png)

## Logic Gates

논리 게이트 : 부울 대수를 이용하여 회로를 설계할때 회로의 기본 단위

![스크린샷 2022-04-12 오후 1.26.01.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.26.01.png)

## Perceptron

인공신경망의 한 종류로, 1957년에 코넬 항공 연구소의 프랑크 로젠블라트(Frank Rosenblatt)에 의해 고안되었다. 이것은 가장 간단한 형태의 피드포워드(Feedforward)네트워크 -선형분류기- 로도 볼 수 있다 -위키백과

[퍼셉트론 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0)

![스크린샷 2022-04-12 오후 1.28.45.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.28.45.png)

### AND 진리표

![스크린샷 2022-04-12 오후 1.31.01.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.31.01.png)

OR 진리표

![스크린샷 2022-04-12 오후 1.32.20.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.32.20.png)

NAND

![스크린샷 2022-04-12 오후 1.34.46.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.34.46.png)

NOR

![스크린샷 2022-04-12 오후 1.36.31.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.36.31.png)

XOR

![스크린샷 2022-04-12 오후 1.37.25.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.37.25.png)

![스크린샷 2022-04-12 오후 1.37.56.png](2%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%A7%20d2cff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.37.56.png)

멀티 레이어 퍼셉트론 (신경망)

```python
import numpy as np
```

```python
def activation(z):
    return 1 / (1+np.exp(-z))
```

```python
def AND(x,y):
    wx = 20
    wy = 20
    bias = -30

    if activation((wx*x + wy*y + bias)) < 0.5: 
        return 0
    else: 
        return 1
```

```python
print(f"x=0, y=0: {AND(0,0)}")
print(f"x=0, y=1: {AND(0,1)}")
print(f"x=1, y=0: {AND(1,0)}")
print(f"x=1, y=1: {AND(1,1)}")
```

```python
def OR(x,y):
    # or 게이트로 작동하기위한 웨이트값 코딩 [+]
    wx = 20
    wy = 20
    bias = -10

    if activation((wx*x + wy*y + bias)) < 0.5: 
        return 0
    else: 
        return 1
```

```python
print(f"x=0, y=0: {OR(0,0)}")
print(f"x=0, y=1: {OR(0,1)}")
print(f"x=1, y=0: {OR(1,0)}")
print(f"x=1, y=1: {OR(1,1)}")
```

```python
def NAND(x,y):
    wx = -20
    wy = -20
    bias = 30

    if activation((wx*x + wy*y + bias)) < 0.5: 
        return 0
    else: 
        return 1
```

```python
print(f"x=0, y=0: {NAND(0,0)}")
print(f"x=0, y=1: {NAND(0,1)}")
print(f"x=1, y=0: {NAND(1,0)}")
print(f"x=1, y=1: {NAND(1,1)}")
```

```python
def NOR(x,y):
    wx = -20
    wy = -20
    bias = 10

    if activation((wx*x + wy*y + bias)) < 0.5: 
        return 0
    else: 
        return 1
```

```python
print(f"x=0, y=0: {NOR(0,0)}")
print(f"x=0, y=1: {NOR(0,1)}")
print(f"x=1, y=0: {NOR(1,0)}")
print(f"x=1, y=1: {NOR(1,1)}")
```

```python
def XOR1(x, y):
    a = NOR(x,x)
    b = NOR(y,y)
    c = NOR(a,b)
    d = NOR(x,y)
    e = NOR(c,d)

    return e
```

```python
print(f"x=0, y=0: {XOR1(0,0)}")
print(f"x=0, y=1: {XOR1(0,1)}")
print(f"x=1, y=0: {XOR1(1,0)}")
print(f"x=1, y=1: {XOR1(1,1)}")
```

```python
def XOR(x, y):
    ############################
    # WRITE CODE HERE 
    a = NAND(x,y)
    b = OR(x,y)
    c = AND(a,b)
    
    return c
```

```python
print(f"x=0, y=0: {XOR(0,0)}")
print(f"x=0, y=1: {XOR(0,1)}")
print(f"x=1, y=0: {XOR(1,0)}")
print(f"x=1, y=1: {XOR(1,1)}")
```